#General paramteters
[General]
#network = networks.${net=simple_scenario_cache_in_the_core,simple_scenario_cache_at_border,one_cache_scenario_3_links, abilene_cost}_network
network = networks.${net=one_cache_scenario_3_links}_network

#<aa> RNG means "random number genetator". By default, all modules use the RNG 0. Here we instantiate two RNGs. RNG 1 will be used only for the traffic generator (client). All the other modules will use the default RNG (RNG 0). See omnet manual section 10.5 for more info about RNGs.
num-rngs=3
**.client[*].rng-0 = 1
**.content_distribution.rng-0 = 1
**.content_store.rng-0 = 2
#</aa>

seed-set = ${rep = 15,16,17,18,19,20}

#####################################################################
########################  Repositories ##############################
#####################################################################
## (In the case of standard topologies, like tree or cascades, 
## repositories are placed within the corresponding ned file.
##Indicates which node is a repository (left blank for random positioning)
		# **.node_repos = "0,1,2,3,4,5,6,7,8,9,10"
##Indecates how many repositories there are on the network
		# **.num_repos  = 11
##Indicates in how many (random) repositories a given content is replicated
		# **.replicas = 1
**.replicas = -1


**.priceratio = ${ priceratiovalue = 10}

		# **.content_distribution_type = "content_distribution"
**.content_distribution_type = "WeightedContentDistribution"


		# **.content_distribution.weights = "${ weights = 0.333_0.333_0.334}"
		# **.content_distribution.weights = "${ weights = 0_0.25_0.75, 0_0.5_0.5, 0_0.75_0.25, 0.25_0_0.75, 0.25_0.25_0.5, 0.25_0.5_0.25, 0.25_0.75_0, 0.5_0.25_0.25, 0.5_0_0.5, 0.75_0_0.25, 0.75_0.25_0}"
**.content_distribution.weights = "${ weights = 0.333_0.333_0.334}"

**.content_distribution.replication_admitted = false

#####################################################################
##########################  Clients  ################################
#####################################################################
## (In the case of standard topologies, like tree or cascades, 
## clients are placed within the corresponding ned file.
##Indicates which node is a client (left blank for random positioning)
		# **.node_clients = "0,1,2,3,4,5,6,7,8,9,10"
##Indicates how many clients there are on the network
		# **.num_clients = 11
##Arriva rate of each timer
**.lambda = ${ lambda = 100}
##Timer indicating that a given content is not downloaded (>> N_D*d, where N_D is the network diameter, and d is the average delay on a link)
**.RTT = 2
##Timer indicating how often checking for a given content download
**.check_time = 0.1


#####################################################################
###################  Content Distribution ###########################
#####################################################################
##Average size of  a content (in chunks)
**.file_size =  1
##Shaping factor of the Zipf distribution
**.alpha = ${a = 1}
##Plateau of the MZipf distribution
**.q = 0
##Cardinality of the catalog
**.objects = ${ctlg = 1e5}

#####################################################################
##########################  Forwarding ##############################
#####################################################################
##Strategy layer (interest forwarding): 
## - spr: send interests toward the closest repository (in terms of hop count)[comcom,techrep]
## - nrr1: nearest replica routing (one phase)
## - nrr:  nearest replica routing (two phases)
## - random_repository: send interests toward one randomly chosen repository among those which store the given chunk[comcom,techrep]
## - parallel_repository: send interests toward all the repositories which store the given chunk[comcom,techrep]
**.FS = "${ F = nrr }"
**.TTL2 = ${ttl = 1000}
**.TTL1= ${ttl}
**.routing_file = ""
**.core_layer.interest_aggregation =  true


#####################################################################
##########################  Caching  ################################
#####################################################################
##Caching meta-algorithms: fixP, lce , no_cache , lcd, btw, prob_cache,costprobSENS
		# **.decision_policy = "${ D = lce, fix0.1, fix0.05, fix0.01, fix0.005, fix0.001, fix0.0001, fix0.00001}"
		# **.decision_policy = "${ D = never, lce, fix0.01, costprobprodcorr0.01, costprobprodplain0.01, costprobcoincorr0.5, costprobcoinplain0.5, costprobcoincorr0.1, costprobcoinplain0.1}"
		# **.decision_policy = "${ D = costprobprodplain0.01, costprobcoincorr0.5, costprobcoinplain0.5, costprobcoincorr0.1, costprobcoinplain0.1,costprobcoincorr0.01, costprobcoinplain0.01}"
		# **.decision_policy = "${ D = never, lce, fix0.01, tailandrank, costprobprodcorr0.01, costprobtailcons}"
**.decision_policy = "${ D = costprobtailcons}"

		# **.xi = ${xi=0.01, 0.025, 0.05, 0.075, 1, 1.25, 1.50, 1.75, 2, 3,5,8 } #	 Power of the costprob decision policy. It has no meaning withother decision policies
		# **.xi = ${xi=0.01, 0.25, 0.50, 0.75, 1.25, 1.50, 1.75, 2 }
**.xi = ${xi=1 }

##Caching algorithms: {lru,lfu,fifo,two,random}_cache
**.RS = "${ R = lru }_cache"
##Cache size (in chunks)
**.cachesize = ${ csize = 1e3}

## Number of bits that caches use to represent the price
**.price_bits = ${ pricebits = 0}



#####################################################################
########################  Statistics ################################
#####################################################################
**.vector-recording = false
##Time window for the stability checking
**.window = ${window=60}
##Sampling hit_rate time 
**.ts = 0.1
## Every **.window secs the engine checks for the stabilization. Every **.ts sec a sample is collected. Thus, the stabilization is checked every N samples, where N = **.window x **.ts .
##Number of nodes to be full (-1 defaults to *all* nodes) for starting statistic collections
**.partial_n = -1
#<aa>
## A cache will be considered stable if the sequence of the last N samples have a variance smaller than
## this value
**.variance_threshold = ${variance=0.05}
#</aa>

##Time of simulation after the stabilization
**.steady = ${ mytime = 1800}


output-vector-file = ${resultdir}/variance-${variance}/window-${window}/simtime-${mytime}/lambda-${lambda}/${net}/q-${pricebits}/F-${F}/D-${D}/xi-${xi}/R-${R}/alpha-${a}/ctlg-${ctlg}/cachesize-${csize}/weights-${weights}/priceratio-${priceratiovalue}/ccn-id${rep}.vec 
output-scalar-file = ${resultdir}/variance-${variance}/window-${window}/simtime-${mytime}/lambda-${lambda}/${net}/q-${pricebits}/F-${F}/D-${D}/xi-${xi}/R-${R}/alpha-${a}/ctlg-${ctlg}/cachesize-${csize}/weights-${weights}/priceratio-${priceratiovalue}/ccn-id${rep}.sca
